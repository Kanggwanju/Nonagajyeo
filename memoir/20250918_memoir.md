# 2025년 9월 18일 반띵 회고록

## 📌 오늘의 경험

오늘은 **백엔드 모임 조회 API 구현과 첫 JPA 네이티브 쿼리 트러블슈팅**을 통해 
데이터베이스 접근의 복잡성을 직접 경험한 의미 있는 하루였다.

특히 **N+1 문제 해결을 위한 네이티브 쿼리 도입 과정**에서 예상치 못한 Enum 바인딩 문제에 부딪히면서,
이론과 실무 사이의 간극을 메우는 **실질적인 문제 해결 능력**을 기를 수 있었다.

---

## 💡 팀 회의와 개발 방향 조정

### 마이페이지 개발로 역할 전환

당초 **최초 약관 동의 페이지** 제작을 계획했지만, 사용자가 참여한 모임 목록을 
볼 수 있는 기능이 우선적으로 필요하다는 팀 판단에 따라 **마이페이지 개발**로 방향을 전환했다.

**마이페이지 구성 요소:**
* **내 정보 섹션**: 사용자 기본 정보 표시
* **참여한 모임 목록**: 승인된 모임들의 페이징 처리된 목록
* **참여 승인 대기중인 모임**: 대기 상태 모임들의 별도 관리

**재사용 컴포넌트 활용:**
* **모임 카드 컴포넌트**: 메인 페이지와 동일한 디자인 일관성 유지
* **페이지네이션**: 한 페이지 최대 4개 모임 표시로 사용성 최적화

→ **기능적 필요성을 우선시**하여 개발 우선순위를 조정하는 **실무적 의사결정 과정**을 경험했다.

---

## 구현한 핵심 성과

### 모임 조회 관련 기능 및 리팩토링 (PR #64)

**사용자별 모임 목록 조회 시스템**을 구축하면서 **확장 가능한 아키텍처** 설계에 중점을 두었다.

**핵심 구현 사항:**
* **페이징 처리된 참여 모임 조회**: `getParticipatedMeetings` API로 대용량 데이터 효율적 처리
* **상태별 필터링 시스템**: `ApplicationStatus` 파라미터로 승인/대기 모임 구분 조회
* **MeetingProfilePageResponse DTO**: 프론트엔드 친화적 응답 구조 설계
* **순환 참조 방지**: `Meeting` 엔티티에 `@ToString exclude` 적용으로 안정성 강화

→ **단일 API로 다양한 모임 상태를 조회**할 수 있는 유연한 구조를 완성했다.

---

## 핵심 트러블슈팅: JPA 네이티브 쿼리 Enum 바인딩 문제

### 문제 상황: N+1 해결에서 새로운 벽에 부딪히다

**3개 테이블 조인으로 인한 N+1 문제**를 해결하기 위해 네이티브 쿼리를 도입했지만, 예상치 못한 문제가 발생했다.

**발생한 문제:**
* **JUnit 테스트는 통과** (`APPROVED` 문자열을 직접 사용했기 때문) 하지만 
  **Postman API 호출 시 빈 결과** 반환
* `ApplicationStatus.PENDING` → JPA가 숫자 `0`으로 자동 변환
* DB에는 `'PENDING'` 문자열로 저장되어 있어 **쿼리 조건 불일치** 발생

### 해결 과정: 명시적 타입 변환으로 문제 해결

**서비스 레이어에서의 전처리 방식**을 도입하여 JPA의 자동 변환을 우회했다.

**해결 방법:**
```java
// 서비스 레이어에서 명시적 문자열 변환
Page<Meeting> meetingPage = meetingsRepository.findMeetingsWithMartByUserIdAndStatus(
    user.getUserId(),
    status.name(), // ✅ Enum을 명시적으로 문자열 변환
    pageable
);
```

**리포지토리 파라미터 타입 변경:**
```java
// String 타입으로 받아 JPA 자동 변환 방지
Page<Meeting> findMeetingsWithMartByUserIdAndStatus(
    @Param("userId") Long userId,
    @Param("status_name") String statusName, // ✅ String 타입으로 변경
    Pageable pageable
);
```

→ **JPA 내부 동작 원리를 이해**하고 **명시적 제어를 통한 문제 해결**을 경험했다.

---

## 리팩토링을 통한 코드 품질 향상

### 중복 코드 제거와 확장성 확보

개발 과정에서 **참여 승인 대기중인 모임 API**를 별도로 만들려다가, 
기존 API와의 유사성을 발견하고 **리팩토링을 통한 통합**을 진행했다.

**리팩토링 성과:**
* **단일 API로 다중 상태 처리**: `status` 파라미터 하나로 승인/대기 모임 모두 조회 가능
* **코드 중복 제거**: 비슷한 로직을 하나의 메서드로 통합
* **확장성 확보**: 추가 모임 상태가 생겨도 쉽게 대응 가능

→ **비슷한 코드가 있으면 리팩토링하라**는 교육 내용을 
실제 상황에 적용하여 **배운 것을 실무에 적용하는 성취감**을 느꼈다.

---

## 설계 단계의 한계와 성장 인사이트

### 초기 와이어프레임의 아쉬움

와이어프레임 단계에서는 구현 방식의 디테일한 부분까지 고려하지 못했던 점이 아쉬웠다.

**현재의 한계:**
* **API 구조 세부 설계 미흡**: 마이페이지 렌더링에서 사용할 
  상태별 필터링, 페이징 구조 등을 초기에 명확히 하지 못함

**향후 개선 방향:**
* **설계 단계에서의 기술적 고려사항 확대**: 단순한 UI/UX를 넘어 구현 방식까지 포함

→ **프로젝트 경험을 통해 초기 설계 단계에서도 디테일한 부분들을 캐치하고 설정하는 능력**을 키워야겠다는 다짐을 했다.

---

## 오늘의 성과와 깨달음

### 복합적 문제 해결 능력 향상

**N+1 문제 → 네이티브 쿼리 도입 → Enum 바인딩 문제 → 명시적 타입 변환** 이라는 일련의 문제 해결 과정을 통해 **단계적 문제 해결 능력**이 크게 향상되었다.
특히 **JUnit은 통과하지만 실제 API는 실패**하는 상황에서 원인을 찾아내고 해결하는 과정이 매우 값진 경험이었다.

### 이론과 실무의 차이 체감

**JPA의 Enum 자동 변환 메커니즘**처럼 **문서나 강의에서는 다루지 않는 실무 상황**을 직접 경험하면서, **이론 학습과 실제 구현 사이의 차이**를 명확히 인식할 수 있었다.

### 리팩토링 사고의 내재화

**비슷한 코드 패턴을 발견하고 자발적으로 리팩토링**을 진행하면서, **배운 내용을 실제 상황에 적용하는 능력**이 향상되었다.
단순한 지식 습득을 넘어 **실무에서 활용할 수 있는 사고방식**을 체득했다.

---

## 느낀 점

* **JPA 네이티브 쿼리의 Enum 바인딩 트러블슈팅**을 통해 **ORM의 내부 동작 원리**를 더 깊이 이해할 수 있었다.
* **N+1 문제 해결 과정**에서 **성능 최적화와 코드 복잡성 사이의 트레이드오프**를 실무적 관점에서 경험했다.
* **리팩토링을 통한 코드 개선**에서 **학습 내용을 실제 상황에 적용하는 성취감**을 느끼면서, 지속적인 코드 품질 향상의 중요성을 깨달았다.
* **설계 단계의 한계를 인식**하면서 **초기 기획 시 기술적 디테일까지 고려하는 역량**을 기워야겠다는 목표를 세웠다.
* **복합적 문제 상황에서의 단계적 접근법**이 **실무 개발자가 갖춰야 할 핵심 역량**임을 깨달으면서, 문제 해결 능력에 대한 자신감이 크게 향상되었다.
